from Crypto.Util.number import *


def gcdExtended(a, b): 
    # Base Case 
    if a == 0 : 
        return b,0,1
             
    gcd,x1,y1 = gcdExtended(b%a, a) 
     
    # Update x and y using results of recursive 
    # call 
    x = y1 - (b//a) * x1 
    y = x1 
     
    return gcd,x,y 
     
 
# Driver code 
e1, e2 = 71, 101
g, x, y = gcdExtended(e1, e2) 
print("gcd(", e1 , "," , e2, ") = ", g, "Where: x = ", x, " and y = ",y) 

# gcd( 71 , 101 ) =  1 Where: x =  37  and y =  -26

# As y is negative, we need to calculate the inverse of c2 :

import gmpy2  # You'll need to install the gmpy2 library

# Define the values

c1 = 1421275848974615267320815554113040672023972283807752574007971561416386636110464890632994733734995114229161525885389065244354678964389211537085513310823751266472044865745324866096898051759507738772227296453397678055024824805366251635154522059070310922367078281343183508274450904681187384450253350434931649011
c2 = 26097095086985946477598349002260598942399303275420948828501512467473619292573670218058274201990116295246084096584962695127706609264424951086000719935218496250047555039460733768633688410770610612614744411304261153778159881980276162174277085197608466835857196307432992312260307797540746411319330318058866868362
n = 87587426608653108851564813489752475287019321764561555461700901651463446024854423042554629096780987943450742890279417241231211446818009232077230407281610183609540264821974669679932743621434901779832901512681108061652309435608446510337833028029876549629818957952682516026313018526405972829923620377438164377109  # Replace with your actual modulus value

# Calculate the modular inverse
inverse_c2 = gmpy2.invert(c2, n)

if inverse_c2 is not None:
    print(f"The modular inverse of c2 modulo n is: {inverse_c2}")
else:
    print("The modular inverse does not exist for the given inputs.")

msg = (pow(c1,x) * pow(inverse_c2,(-y))) % n

print("Message: ", long_to_bytes(msg))
